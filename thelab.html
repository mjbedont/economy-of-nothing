<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VOID / ZERO SYSTEM</title>
    <style>
        :root {
            --bg: #050505;
            --surface: #111;
            --p1: #00f2ff; /* Alpha - Cyan */
            --p2: #ff0055; /* Omega - Crimson */
            --text: #e0e0e0;
            --border: #222;
        }
        * { box-sizing: border-box; touch-action: manipulation; }
        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Courier New', monospace;
            display: flex; flex-direction: column; align-items: center;
            margin: 0; padding: 5px; text-transform: uppercase;
            height: 100vh; overflow: hidden;
        }

        #header { text-align: center; width: 100%; max-width: 400px; flex-shrink: 0; }
        #rules { font-size: 9px; color: #444; border: 1px solid var(--border); padding: 5px; margin-bottom: 5px; }
        
        #score-box { 
            border: 1px solid var(--p1); background: rgba(0, 242, 255, 0.05);
            width: 100%; padding: 5px; display: flex; justify-content: space-around; 
            margin-bottom: 5px; font-size: 12px; color: var(--p1); 
        }

        #status-row { display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 5px; width: 100%; max-width: 400px; }

        #board {
            display: grid; grid-template-columns: repeat(9, 9vmin); grid-template-rows: repeat(9, 9vmin);
            gap: 1px; background-color: var(--border); border: 2px solid var(--border);
        }

        .cell {
            width: 9vmin; height: 9vmin; background-color: var(--bg);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; -webkit-tap-highlight-color: transparent;
        }

        .piece { 
            width: 80%; height: 80%; display: flex; align-items: center; justify-content: center; 
            font-size: 16px; font-weight: bold; transition: transform 0.1s;
        }

        .p1 { color: var(--p1); text-shadow: 0 0 8px var(--p1); }
        .p2 { color: var(--p2); text-shadow: 0 0 8px var(--p2); }
        .hidden { color: #444; text-shadow: none; }

        .selected { background-color: var(--surface); box-shadow: inset 0 0 10px var(--p1); }
        
        /* Combat Shake Animation */
        .shake { animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        #log {
            margin-top: 10px; width: 81vmin; max-width: 400px; height: 45px;
            font-size: 9px; color: #666; overflow: hidden;
            border-left: 2px solid var(--p1); padding-left: 10px; flex-shrink: 0;
        }
    </style>
</head>
<body>

    <div id="header">
        <div id="rules">COMBAT PROTOCOL: RANDOMIZED // FOG OF WAR ACTIVE</div>
        <div id="score-box">
            <span>XP: <span id="current-score">0</span></span>
            <span>TOP_PILOT: <span id="high-score">0</span></span>
        </div>
        <div id="status-row">
            <div id="status">ZERO_SYSTEM_ACTIVE</div>
            <div id="turn-display" style="color: var(--p1)">SYNC: ALPHA</div>
        </div>
    </div>

    <div id="board"></div>
    <div id="log"></div>

    <script>
        const board = document.getElementById('board');
        const turnDisplay = document.getElementById('turn-display');
        const scoreEl = document.getElementById('current-score');
        const highEl = document.getElementById('high-score');
        const log = document.getElementById('log');

        let selected = null;
        let turn = 'p1'; 
        let active = true;
        let kills = 0, deaths = 0, breachBonus = 0;
        let pieces = {};
        const winMap = { 'R': 'S', 'S': 'P', 'P': 'R' };

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function setupGame() {
            pieces = {};
            const p1Types = shuffle(['R', 'R', 'P', 'P', 'S', 'S']);
            const p2Types = shuffle(['R', 'R', 'P', 'P', 'S', 'S']);
            const p1Pos = ["8-2", "8-3", "8-4", "8-5", "8-6", "7-4"];
            const p2Pos = ["0-2", "0-3", "0-4", "0-5", "0-6", "1-4"];

            p1Pos.forEach((pos, i) => pieces[pos] = {o:'p1', t:p1Types[i], known: true});
            p2Pos.forEach((pos, i) => pieces[pos] = {o:'p2', t:p2Types[i], known: false});
            
            highEl.textContent = localStorage.getItem('zero_high') || 0;
            init();
        }

        function writeLog(msg) {
            const entry = document.createElement('div');
            entry.textContent = `> ${msg}`;
            log.prepend(entry);
        }

        function updateScore() {
            let proximity = 0;
            for (let k in pieces) if (pieces[k].o === 'p1') proximity += (8 - parseInt(k.split('-')[0])) * 15;
            const score = (kills * 150) - (deaths * 50) + proximity + breachBonus;
            scoreEl.textContent = Math.max(0, score);
            if (score > (localStorage.getItem('zero_high') || 0)) localStorage.setItem('zero_high', score);
        }

        function init() {
            board.innerHTML = '';
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    const key = `${r}-${c}`;
                    if (pieces[key]) {
                        const p = pieces[key];
                        const pDiv = document.createElement('div');
                        pDiv.className = `piece ${p.o} ${(!p.known && p.o === 'p2') ? 'hidden' : ''}`;
                        pDiv.textContent = (p.known || p.o === 'p1') ? p.t : '?';
                        cell.appendChild(pDiv);
                    }
                    if (selected?.r === r && selected?.c === c) cell.classList.add('selected');
                    cell.onclick = () => { if(turn === 'p1' && active) handleTap(r, c); };
                    board.appendChild(cell);
                }
            }
            updateScore();
        }

        function handleTap(r, c) {
            const p = pieces[`${r}-${c}`];
            if (p?.o === 'p1') { selected = { r, c }; init(); } 
            else if (selected) {
                if (Math.abs(r - selected.r) <= 1 && Math.abs(c - selected.c) <= 1) processMove(selected.r, selected.c, r, c);
                else { selected = null; init(); }
            }
        }

        function processMove(fr, fc, tr, tc) {
            const att = pieces[`${fr}-${fc}`];
            const def = pieces[`${tr}-${tc}`];
            
            if (def && (def.o === att.o || (def.known && att.t === def.t))) return;

            if (def) {
                board.classList.add('shake');
                setTimeout(() => board.classList.remove('shake'), 300);
                def.known = true; // Reveal on clash
                
                if (att.t === def.t) {
                    writeLog(`KINETIC HALT: ${att.t} vs ${def.t}`);
                    return;
                }

                if (winMap[att.t] === def.t) {
                    writeLog(`CRITICAL: ${att.t} DESTROYED ${def.t}`);
                    pieces[`${tr}-${tc}`] = att;
                    att.o === 'p1' ? kills++ : deaths++;
                } else {
                    writeLog(`COUNTER: ${att.t} VAPORIZED BY ${def.t}`);
                    att.o === 'p1' ? deaths++ : kills++;
                }
            } else {
                pieces[`${tr}-${tc}`] = att;
            }

            delete pieces[`${fr}-${fc}`];
            selected = null;
            
            if (att.o === 'p1' && tr === 0) { breachBonus = 1000; return finish("TARGET AREA BREACHED."); }
            if (att.o === 'p2' && tr === 8) return finish("BASE DEFENSES COLLAPSED.");

            const counts = Object.values(pieces).reduce((acc, p) => { acc[p.o]++; return acc; }, {p1:0, p2:0});
            if (counts.p1 === 0 || counts.p2 === 0) return finish("COMBATANTS ELIMINATED.");

            turn = (turn === 'p1') ? 'p2' : 'p1';
            updateUI(); init();
            if (turn === 'p2' && active) setTimeout(aiBrain, 600);
        }

        function aiBrain() {
            let moves = [];
            let p1Lead = 8;
            for (let k in pieces) if(pieces[k].o === 'p1') p1Lead = Math.min(p1Lead, parseInt(k.split('-')[0]));

            for (let k in pieces) {
                if (pieces[k].o === 'p2') {
                    const [r, c] = k.split('-').map(Number);
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            let nr = r + dr, nc = c + dc;
                            if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9) {
                                let target = pieces[`${nr}-${nc}`];
                                if (!target || (target.o === 'p1' && pieces[k].t !== target.t)) {
                                    let score = nr * 5; 
                                    if (target && winMap[pieces[k].t] === target.t) score += 60;
                                    if (nr > p1Lead) score += 40; 
                                    moves.push({ fr: r, fc: c, tr: nr, tc: nc, score });
                                }
                            }
                        }
                    }
                }
            }
            if (!moves.length) { turn = 'p1'; updateUI(); return; }
            moves.sort((a, b) => b.score - a.score || Math.random() - 0.5);
            processMove(moves[0].fr, moves[0].fc, moves[0].tr, moves[0].tc);
        }

        function updateUI() {
            turnDisplay.textContent = `SYNC: ${turn === 'p1' ? 'ALPHA' : 'OMEGA'}`;
            turnDisplay.style.color = turn === 'p1' ? 'var(--p1)' : 'var(--p2)';
        }

        function finish(m) { active = false; updateScore(); alert(`${m}\nFINAL XP: ${scoreEl.textContent}`); location.reload(); }
        
        setupGame();
    </script>
</body>
</html>
